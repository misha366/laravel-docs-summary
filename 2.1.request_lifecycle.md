Жизненный цикл:

1. первые шаги
Точкой входа для всех веб запросов к приложению Laravel является `public/index.php` файл - весь роутинг на ларе (2тип). Все запросы должны направлятся на этот файл конфигурацией Apache/Nginx веб сервера, веб сервер не должен заниматся роутингом, это всё будет делать ларавел через index.php и обработку роутов (2тип). Файл index.php не содежит много кода, это просто отправная точка для загрузки остальных частей фреймворка.


перед всеми операциями ларавел определяет константу LARAVEL_START, в которой сохраняется метка времени Unix в микросекундах

Сначала index.php проверяет не находится ли приложение в режиме обслуживания; потом загружает автозагрузчик composer и в конце *извлекает экземпляр приложения Laravel из bootstrap/app.php*

Первое, что происходит при попытке вытянуть экземпляр приложения ларавел - его создание.

```php
$app = require_once __DIR__.'/../bootstrap/app.php';

return Application::configure(basePath: dirname(__DIR__))
    ->withRouting(
```

С помощью фабричного метода configure мы создаём инстанс `Illuminate\Foundation\Application` и возвращаем его в index.php/artisan файл

И естественно в вебе под каждое новое соединение, под каждый отдельно взятый запрос будет создаватся отдельный инстанс приложения ларавел, потому что он создаётся внутри воркера в пуле php-fpm.

Следующим этапом является передача информации о текущем запросе:
- Для веб ядра мы будем использовать фабричный метод `Request::capture()`, что возвращает нам инстанс `Illuminate/Http/Request` и записывает в него текущие глобальные значения запроса.
```php
Request::capture()
```
- Для консоли создаём обёртку над $argv - Symfony\Component\Console\Input\ArgvInput
```php
new ArgvInput
```

И переходим к отправке запроса в одно из ядер - http либо console

2. HTTP / Console Kernels
После передачи запроса в инстанс он отправляется либо в ядро http, либо в ядро консоли (с помощью методов handleRequest, handleCommand), в зависимости от типа запроса, что поступает в приложение.

Эти 2 ядра (kernels) служат центральными местами, через которые проходят все запросы. 
Http kernel - инстанс Illuminate\Foundation\Http\Kernel

Ядро http определяет массив `bootstrapers` (загрузчиков), которые будут запущены перед выполнением запроса. Эти загрузчики настраивают обработку ошибок, настраивают ведение журнала, определяют среду приложение (.env) и выполняют другие задачи, которые надо выполнить перед фактическим выполнением запроса. Обычно эти классы обслуживают внутренюю конфигурацию ларавел.

Так же ядро http отвечает за передачу запроса через стек middleware, который отвечает за: обработку хттп сессий, режима обслуживания, подтверждения CSRF токена и др.

Http метод `handle` работает очень просто - он получает `Request` и возвращает `Response`.


3. Service providers (ЗАВИСИМОСТИ)

> Service providers регистрируют зависимости и другие сервисы в контейнер Laravel (IoC), чтобы их можно было вызывать откуда угодно — через DI, фасады, хелперы и т.д.

Одним из самых важных действий при загрузке ядра является загрузка service providers (поставщиков) нашего приложения. Поставщики отвечают за загрузку *базы данных, очереди, валидации и компонентов маршрутизации*. Пользовательский список конфигурируется в `bootstrap/providers.php`, хотя под капотом ларавел использует десятки поставщиков услуг для своих потребностей.

После создания приложения Laravel будет проходить по этому списку поставщиков и создавать экземпляры каждого из них. После создания у всех поставщиков будет вызван метод `register` - регистрирует в контейнере IoC. Как только все поставщики будут зарегистрированы для каждого будет вызван `boot` метод - выполняет необходимые действия после регистрации всех провайдеров.

По сути, каждая крупная ф-я предлагаемая ларавел, загружается и настраивается поставщиком услуг. Поскольку они загружают и настраивают так много функций, предлагаемых фреймворком, поставщики услуг являются наиболее важным аспектом всего процесса загрузки laravel.

4. Маршрутизация
После того, как приложение будет загружено и все поставщики услуг будут зарегистрированы, объект `Request` будет передан маршрутизатору для отправки на контроллер, так же запустит любое нужное промежуточное ПО, специфичное для маршрута.

Промежуточное ПО (middleware) - удобный механизм для фильтрации/проверки входящих HTTP запросов. Внедряется с помщью HTTP пайплайна.

> ! ПО - путаница перевода, на самом деле там нету полноценного по, это просто слой кода, который срабатывает перед передачей маршрутизатором Request'а в контроллер. 

Пример - у ларавел есть встроенное промежуточное по, которое проверяет, аутентифицирован ли клиент (тот, кто отправил `Request`). Если пользователь не аутентифицированmiddleware перенаправит пользователя на экран входа в систему. Однако если аутентифицирован (есть валидный sid либо токен в запросе).

Некоторые middleware назначаются *по всем маршрутам*, например `PreventRequestsDuringMaintenance`, в то время как некоторые назначаются только определённым маршрутам или группам маршрутов


Что может middleware:
- отфильтровать или модифицировать запрос (Request)
- прервать цепочку обработки запроса и вернуть Response сам
- изменить ответ, после того как контроллер отработал

5. Завершение
После того как отработал контроллер отработал, ответ передаётся обратно наверх - к роутеру в промежуточное по, после этого обратно в метод `handle`.
`handle` метод 

